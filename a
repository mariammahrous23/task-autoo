from heapq import heappop, heappush

def heuristic(position, goal):
    # Manhattan distance heuristic
    return abs(position[0] - goal[0]) + abs(position[1] - goal[1])

def solve_maze():
    # Initialize the priority queue for A* (using heap)
    queue = [(heuristic(getRobotPos(), getGoalPos()), getRobotPos(), [])]  # (heuristic, position, path_taken)
    visited = set()  # Set to keep track of visited positions
    
    while queue:
        _, current_pos, path = heappop(queue)
        
        # Check if the current position is the goal
        if current_pos == getGoalPos():
            return path
        
        # Mark current position as visited
        visited.add(current_pos)
        
        # Check neighboring cells (right and down)
        for right, down in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            new_pos = (current_pos[0] + down, current_pos[1] + right)
            
            # Check if the new position is within the warehouse boundaries and walkable
            if isWalkable(right, down) and new_pos not in visited:
                new_heuristic = heuristic(new_pos, getGoalPos())
                heappush(queue, (new_heuristic, new_pos, path + [(right, down)]))
    
    # No path found
    return None

# Call the function to solve the maze
solution_path = solve_maze()

if solution_path:
    for right, down in solution_path:
        moveRobot(right, down)  # Move the robot according to the solution path
else:
    print("No solution found.")
